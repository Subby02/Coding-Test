import sys

n , m = map(int , sys.stdin.readline().split())

graph = [[False] * (n+1) for _ in range(n+1)]
cnt = [0] * (n+1)

for _ in range(m):
  a , b = map(int , sys.stdin.readline().split())
  graph[a][b] = True

for k in range(1,n+1):
  for a in range(1,n+1):
    for b in range(1,n+1):
      if graph[a][k] and graph[k][b]:
        graph[a][b] = True

for i in range(1,n+1):
  for j in range(1,n+1):
    if graph[i][j]:
      cnt[i] += 1
      cnt[j] += 1

print(cnt.count(n-1))

# 1. 일단 먼저 문제를 이해 해보자면 정확한 순위를 알기 위해선 임의로 고른 학생이 다른 학생들과 모두 다 비교가 가능하면 정확한 순위를 알 수 있다. 이게 무슨 말이냐면 만약 4번 학생 보다 낮은 학생이 3명이고 높은 학생이 2명이면 (4번 학생 보다 낮은 3명) | 4번 학생 | (4번 학생 보다 높은 2명) 이므로 자신을 제외한 모든 학생이랑 비교가 가능하므로 4번 학생은 4등이라는 것이 당연해진다. 
# 2. 이러한 이해를 바탕으로 다익스트라와 플로이드 중 어떤것이 나을지 생각을 해봤다. 결국엔 각 학생 마다 비교가 가능한 학생 수를 세야 하므로 모든 노드에서 모든 노드로 가는 플로이드가 좀 더 효율적이다고 생각했다. 물론 다익스트라로 풀 수 있지만 한 노드에서 모든 노드를 가는 걸 다시 각 학생마다 진행해야 하므로 비효율적이다고 생각했다.
# 3. 플로이드를 이용할때 단지 그냥 비교가 가능한지 여부만 생각하면 된다고 해서 그냥 boolean을 이용하기로 했다. 플로이드를 해줘서 각 학생 마다 비교 여부를 저장해주고 그래프를 전체적으로 탐색해서 만약 비교가 가능하면 cnt라는 리스트에 해당 학생에 비교 가능한 한생 수를 증가 시켰다. cnt에 저장된 값 중 n-1인 값을 카운트 해서 출력해줬다. 즉 (비교 가능한 학생 수) = (총 학생수) - (자기 자신) 이면 정확한 순위를 알 수 있다.
# 4. 다른 사람들의 코드를 보니 대부분 boolean을 이용하지 않고 숫자로 하던데 이게 좀 더 이해가 잘 되는 거 같다. 별 차이는 없다고 생각한다.