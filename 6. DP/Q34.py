import sys

n = int(sys.stdin.readline())

soldier = list(map(int, sys.stdin.readline().split()))
soldier.reverse()

d = [1] * (n)

for i in range(1,n):
  for j in range(0,i):
    if soldier[j] < soldier[i]:
      d[i] = max(d[i] , d[j]+1)

print(n-max(d))

# 1. 문제를 아무리 봐도 모르겠어서 답을 보게 되었다. 뭔가 내가 풀려고 했던 방식이랑 살짝 비슷한거 같기도 하다는 생각이 든다. 여튼 답을 읽어도 처음에 이해가 안되서 이해를 할려고 직접 for문안에 d 값이 실시간으로 어떻게 변하는지 봐서 이해 할려고 노력했다. 
# 2. 이 문제는 최장 증가 부분 수열로 LIS 문제라는데 설명하자면 어떤 수열이 주어졌을때 해당 수열의 부분 수열중에 오름차순이고 가장 긴 부분 수열을 의미한다. 이게 뭔 말인지 맨처음에 딱 보면 모르는데 천천히 읽어보면 된다. 여튼 첫번째 for문은 i번째 원소를 마지막으로 가지는 부분 수열을 의미 한다. dp 문제를 보면 차근차근 계단을 쌓듯이 문제를 풀 수 있는 방식으로 가야 되는거 같다. 그래서 i+1번째 원소를 마지막으로 가지는 부분 수열은 앞에 부분 수열에 오름차순으로 들어가는 원소가 오면 해당 값에 알맞은 순서 값(?)을 주는것이다. 이렇게 차근차근 최대 길이를 늘려나간다.